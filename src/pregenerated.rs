// Danger: this file was NOT generated at run time and could be out of date
// Targets libplist v2.6.0
/* automatically generated by rust-bindgen 0.70.1 */

pub const __WORDSIZE: u32 = 64;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const USE_CLANG_TYPES: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const BYTE_ORDER: u32 = 1234;
pub const USE_CLANG_STDDEF: u32 = 0;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __MAC_15_0: u32 = 150000;
pub const __MAC_15_1: u32 = 150100;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __IPHONE_18_0: u32 = 180000;
pub const __IPHONE_18_1: u32 = 180100;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __WATCHOS_11_0: u32 = 110000;
pub const __WATCHOS_11_1: u32 = 110100;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __TVOS_18_0: u32 = 180000;
pub const __TVOS_18_1: u32 = 180100;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __BRIDGEOS_9_0: u32 = 90000;
pub const __BRIDGEOS_9_1: u32 = 90100;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __DRIVERKIT_24_0: u32 = 240000;
pub const __DRIVERKIT_24_1: u32 = 240100;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const __VISIONOS_2_0: u32 = 20000;
pub const __VISIONOS_2_1: u32 = 20100;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const MAC_OS_VERSION_15_0: u32 = 150000;
pub const MAC_OS_VERSION_15_1: u32 = 150100;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 150100;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const USE_CLANG_STDARG: u32 = 0;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 128usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 8usize];
    ["Offset of field: __mbstate_t::__mbstate8"]
        [::std::mem::offset_of!(__mbstate_t, __mbstate8) - 0usize];
    ["Offset of field: __mbstate_t::_mbstateL"]
        [::std::mem::offset_of!(__mbstate_t, _mbstateL) - 0usize];
};
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_pthread_handler_rec"]
        [::std::mem::size_of::<__darwin_pthread_handler_rec>() - 24usize];
    ["Alignment of __darwin_pthread_handler_rec"]
        [::std::mem::align_of::<__darwin_pthread_handler_rec>() - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__routine"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __routine) - 0usize];
    ["Offset of field: __darwin_pthread_handler_rec::__arg"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __arg) - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__next"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __next) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_attr_t"][::std::mem::size_of::<_opaque_pthread_attr_t>() - 64usize];
    ["Alignment of _opaque_pthread_attr_t"]
        [::std::mem::align_of::<_opaque_pthread_attr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_attr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_attr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_cond_t"][::std::mem::size_of::<_opaque_pthread_cond_t>() - 48usize];
    ["Alignment of _opaque_pthread_cond_t"]
        [::std::mem::align_of::<_opaque_pthread_cond_t>() - 8usize];
    ["Offset of field: _opaque_pthread_cond_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_cond_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_condattr_t"]
        [::std::mem::size_of::<_opaque_pthread_condattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_condattr_t"]
        [::std::mem::align_of::<_opaque_pthread_condattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_condattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_condattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutex_t"][::std::mem::size_of::<_opaque_pthread_mutex_t>() - 64usize];
    ["Alignment of _opaque_pthread_mutex_t"]
        [::std::mem::align_of::<_opaque_pthread_mutex_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutex_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutex_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutexattr_t"]
        [::std::mem::size_of::<_opaque_pthread_mutexattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_mutexattr_t"]
        [::std::mem::align_of::<_opaque_pthread_mutexattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_once_t"][::std::mem::size_of::<_opaque_pthread_once_t>() - 16usize];
    ["Alignment of _opaque_pthread_once_t"]
        [::std::mem::align_of::<_opaque_pthread_once_t>() - 8usize];
    ["Offset of field: _opaque_pthread_once_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_once_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlock_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlock_t>() - 200usize];
    ["Alignment of _opaque_pthread_rwlock_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlock_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlockattr_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() - 24usize];
    ["Alignment of _opaque_pthread_rwlockattr_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_t"][::std::mem::size_of::<_opaque_pthread_t>() - 8192usize];
    ["Alignment of _opaque_pthread_t"][::std::mem::align_of::<_opaque_pthread_t>() - 8usize];
    ["Offset of field: _opaque_pthread_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_t::__cleanup_stack"]
        [::std::mem::offset_of!(_opaque_pthread_t, __cleanup_stack) - 8usize];
    ["Offset of field: _opaque_pthread_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_t, __opaque) - 16usize];
};
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 4usize];
    ["Offset of field: fd_set::fds_bits"][::std::mem::offset_of!(fd_set, fds_bits) - 0usize];
};
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sbuf"][::std::mem::size_of::<__sbuf>() - 16usize];
    ["Alignment of __sbuf"][::std::mem::align_of::<__sbuf>() - 8usize];
    ["Offset of field: __sbuf::_base"][::std::mem::offset_of!(__sbuf, _base) - 0usize];
    ["Offset of field: __sbuf::_size"][::std::mem::offset_of!(__sbuf, _size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sFILE"][::std::mem::size_of::<__sFILE>() - 152usize];
    ["Alignment of __sFILE"][::std::mem::align_of::<__sFILE>() - 8usize];
    ["Offset of field: __sFILE::_p"][::std::mem::offset_of!(__sFILE, _p) - 0usize];
    ["Offset of field: __sFILE::_r"][::std::mem::offset_of!(__sFILE, _r) - 8usize];
    ["Offset of field: __sFILE::_w"][::std::mem::offset_of!(__sFILE, _w) - 12usize];
    ["Offset of field: __sFILE::_flags"][::std::mem::offset_of!(__sFILE, _flags) - 16usize];
    ["Offset of field: __sFILE::_file"][::std::mem::offset_of!(__sFILE, _file) - 18usize];
    ["Offset of field: __sFILE::_bf"][::std::mem::offset_of!(__sFILE, _bf) - 24usize];
    ["Offset of field: __sFILE::_lbfsize"][::std::mem::offset_of!(__sFILE, _lbfsize) - 40usize];
    ["Offset of field: __sFILE::_cookie"][::std::mem::offset_of!(__sFILE, _cookie) - 48usize];
    ["Offset of field: __sFILE::_close"][::std::mem::offset_of!(__sFILE, _close) - 56usize];
    ["Offset of field: __sFILE::_read"][::std::mem::offset_of!(__sFILE, _read) - 64usize];
    ["Offset of field: __sFILE::_seek"][::std::mem::offset_of!(__sFILE, _seek) - 72usize];
    ["Offset of field: __sFILE::_write"][::std::mem::offset_of!(__sFILE, _write) - 80usize];
    ["Offset of field: __sFILE::_ub"][::std::mem::offset_of!(__sFILE, _ub) - 88usize];
    ["Offset of field: __sFILE::_extra"][::std::mem::offset_of!(__sFILE, _extra) - 104usize];
    ["Offset of field: __sFILE::_ur"][::std::mem::offset_of!(__sFILE, _ur) - 112usize];
    ["Offset of field: __sFILE::_ubuf"][::std::mem::offset_of!(__sFILE, _ubuf) - 116usize];
    ["Offset of field: __sFILE::_nbuf"][::std::mem::offset_of!(__sFILE, _nbuf) - 119usize];
    ["Offset of field: __sFILE::_lb"][::std::mem::offset_of!(__sFILE, _lb) - 120usize];
    ["Offset of field: __sFILE::_blksize"][::std::mem::offset_of!(__sFILE, _blksize) - 136usize];
    ["Offset of field: __sFILE::_offset"][::std::mem::offset_of!(__sFILE, _offset) - 144usize];
};
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: va_list,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The basic plist abstract data type."]
pub type plist_t = *mut ::std::os::raw::c_void;
#[doc = " The plist dictionary iterator."]
pub type plist_dict_iter = *mut ::std::os::raw::c_void;
#[doc = " The plist array iterator."]
pub type plist_array_iter = *mut ::std::os::raw::c_void;
#[doc = "< No type"]
pub const plist_type_PLIST_NONE: plist_type = -1;
#[doc = "< Boolean, scalar type"]
pub const plist_type_PLIST_BOOLEAN: plist_type = 0;
#[doc = "< Integer, scalar type"]
pub const plist_type_PLIST_INT: plist_type = 1;
#[doc = "< Real, scalar type"]
pub const plist_type_PLIST_REAL: plist_type = 2;
#[doc = "< ASCII string, scalar type"]
pub const plist_type_PLIST_STRING: plist_type = 3;
#[doc = "< Ordered array, structured type"]
pub const plist_type_PLIST_ARRAY: plist_type = 4;
#[doc = "< Unordered dictionary (key/value pair), structured type"]
pub const plist_type_PLIST_DICT: plist_type = 5;
#[doc = "< Date, scalar type"]
pub const plist_type_PLIST_DATE: plist_type = 6;
#[doc = "< Binary data, scalar type"]
pub const plist_type_PLIST_DATA: plist_type = 7;
#[doc = "< Key in dictionaries (ASCII String), scalar type"]
pub const plist_type_PLIST_KEY: plist_type = 8;
#[doc = "< Special type used for 'keyed encoding'"]
pub const plist_type_PLIST_UID: plist_type = 9;
#[doc = "< NULL type"]
pub const plist_type_PLIST_NULL: plist_type = 10;
#[doc = " The enumeration of plist node types."]
pub type plist_type = ::std::os::raw::c_int;
#[doc = "< operation successful"]
pub const plist_err_t_PLIST_ERR_SUCCESS: plist_err_t = 0;
#[doc = "< one or more of the parameters are invalid"]
pub const plist_err_t_PLIST_ERR_INVALID_ARG: plist_err_t = -1;
#[doc = "< the plist contains nodes not compatible with the output format"]
pub const plist_err_t_PLIST_ERR_FORMAT: plist_err_t = -2;
#[doc = "< parsing of the input format failed"]
pub const plist_err_t_PLIST_ERR_PARSE: plist_err_t = -3;
#[doc = "< not enough memory to handle the operation"]
pub const plist_err_t_PLIST_ERR_NO_MEM: plist_err_t = -4;
#[doc = "< I/O error"]
pub const plist_err_t_PLIST_ERR_IO: plist_err_t = -5;
#[doc = "< an unspecified error occurred"]
pub const plist_err_t_PLIST_ERR_UNKNOWN: plist_err_t = -255;
#[doc = " libplist error values"]
pub type plist_err_t = ::std::os::raw::c_int;
#[doc = "< No format"]
pub const plist_format_t_PLIST_FORMAT_NONE: plist_format_t = 0;
#[doc = "< XML format"]
pub const plist_format_t_PLIST_FORMAT_XML: plist_format_t = 1;
#[doc = "< bplist00 format"]
pub const plist_format_t_PLIST_FORMAT_BINARY: plist_format_t = 2;
#[doc = "< JSON format"]
pub const plist_format_t_PLIST_FORMAT_JSON: plist_format_t = 3;
#[doc = "< OpenStep \"old-style\" plist format"]
pub const plist_format_t_PLIST_FORMAT_OSTEP: plist_format_t = 4;
#[doc = "< human-readable output-only format"]
pub const plist_format_t_PLIST_FORMAT_PRINT: plist_format_t = 10;
#[doc = "< \"libimobiledevice\" output-only format (ideviceinfo)"]
pub const plist_format_t_PLIST_FORMAT_LIMD: plist_format_t = 11;
#[doc = "< plutil-style output-only format"]
pub const plist_format_t_PLIST_FORMAT_PLUTIL: plist_format_t = 12;
#[doc = " libplist format types"]
pub type plist_format_t = ::std::os::raw::c_uint;
#[doc = "< Default value to use when none of the options is needed."]
pub const plist_write_options_t_PLIST_OPT_NONE: plist_write_options_t = 0;
#[doc = "< Use a compact representation (non-prettified). Only valid for #PLIST_FORMAT_JSON and #PLIST_FORMAT_OSTEP."]
pub const plist_write_options_t_PLIST_OPT_COMPACT: plist_write_options_t = 1;
#[doc = "< Print 24 bytes maximum of #PLIST_DATA values. If the data is longer than 24 bytes,  the first 16 and last 8 bytes will be written. Only valid for #PLIST_FORMAT_PRINT."]
pub const plist_write_options_t_PLIST_OPT_PARTIAL_DATA: plist_write_options_t = 2;
#[doc = "< Do not print a final newline character. Only valid for #PLIST_FORMAT_PRINT, #PLIST_FORMAT_LIMD, and #PLIST_FORMAT_PLUTIL."]
pub const plist_write_options_t_PLIST_OPT_NO_NEWLINE: plist_write_options_t = 4;
#[doc = "< Indent each line of output. Currently only #PLIST_FORMAT_PRINT and #PLIST_FORMAT_LIMD are supported. Use #PLIST_OPT_INDENT_BY() macro to specify the level of indentation."]
pub const plist_write_options_t_PLIST_OPT_INDENT: plist_write_options_t = 8;
#[doc = " libplist write options"]
pub type plist_write_options_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create a new root plist_t type #PLIST_DICT\n\n @return the created plist\n @sa #plist_type"]
    pub fn plist_new_dict() -> plist_t;
}
extern "C" {
    #[doc = " Create a new root plist_t type #PLIST_ARRAY\n\n @return the created plist\n @sa #plist_type"]
    pub fn plist_new_array() -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_STRING\n\n @param val the sting value, encoded in UTF8.\n @return the created item\n @sa #plist_type"]
    pub fn plist_new_string(val: *const ::std::os::raw::c_char) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_BOOLEAN\n\n @param val the boolean value, 0 is false, other values are true.\n @return the created item\n @sa #plist_type"]
    pub fn plist_new_bool(val: u8) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_INT with an unsigned integer value\n\n @param val the unsigned integer value\n @return the created item\n @sa #plist_type\n @note The value is always stored as uint64_t internally.\n    Use #plist_get_uint_val or #plist_get_int_val to get the unsigned or signed value."]
    pub fn plist_new_uint(val: u64) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_INT with a signed integer value\n\n @param val the signed integer value\n @return the created item\n @sa #plist_type\n @note The value is always stored as uint64_t internally.\n    Use #plist_get_uint_val or #plist_get_int_val to get the unsigned or signed value."]
    pub fn plist_new_int(val: i64) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_REAL\n\n @param val the real value\n @return the created item\n @sa #plist_type"]
    pub fn plist_new_real(val: f64) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_DATA\n\n @param val the binary buffer\n @param length the length of the buffer\n @return the created item\n @sa #plist_type"]
    pub fn plist_new_data(val: *const ::std::os::raw::c_char, length: u64) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_DATE\n\n @param sec the number of seconds since 01/01/2001\n @param usec the number of microseconds\n @return the created item\n @sa #plist_type"]
    pub fn plist_new_date(sec: i32, usec: i32) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_UID\n\n @param val the unsigned integer value\n @return the created item\n @sa #plist_type"]
    pub fn plist_new_uid(val: u64) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_NULL\n @return the created item\n @sa #plist_type\n @note This type is not valid for all formats, e.g. the XML format\n     does not support it."]
    pub fn plist_new_null() -> plist_t;
}
extern "C" {
    #[doc = " Destruct a plist_t node and all its children recursively\n\n @param plist the plist to free"]
    pub fn plist_free(plist: plist_t);
}
extern "C" {
    #[doc = " Return a copy of passed node and it's children\n\n @param node the plist to copy\n @return copied plist"]
    pub fn plist_copy(node: plist_t) -> plist_t;
}
extern "C" {
    #[doc = " Get size of a #PLIST_ARRAY node.\n\n @param node the node of type #PLIST_ARRAY\n @return size of the #PLIST_ARRAY node"]
    pub fn plist_array_get_size(node: plist_t) -> u32;
}
extern "C" {
    #[doc = " Get the nth item in a #PLIST_ARRAY node.\n\n @param node the node of type #PLIST_ARRAY\n @param n the index of the item to get. Range is [0, array_size[\n @return the nth item or NULL if node is not of type #PLIST_ARRAY"]
    pub fn plist_array_get_item(node: plist_t, n: u32) -> plist_t;
}
extern "C" {
    #[doc = " Get the index of an item. item must be a member of a #PLIST_ARRAY node.\n\n @param node the node\n @return the node index or UINT_MAX if node index can't be determined"]
    pub fn plist_array_get_item_index(node: plist_t) -> u32;
}
extern "C" {
    #[doc = " Set the nth item in a #PLIST_ARRAY node.\n The previous item at index n will be freed using #plist_free\n\n @param node the node of type #PLIST_ARRAY\n @param item the new item at index n. The array is responsible for freeing item when it is no longer needed.\n @param n the index of the item to get. Range is [0, array_size[. Assert if n is not in range."]
    pub fn plist_array_set_item(node: plist_t, item: plist_t, n: u32);
}
extern "C" {
    #[doc = " Append a new item at the end of a #PLIST_ARRAY node.\n\n @param node the node of type #PLIST_ARRAY\n @param item the new item. The array is responsible for freeing item when it is no longer needed."]
    pub fn plist_array_append_item(node: plist_t, item: plist_t);
}
extern "C" {
    #[doc = " Insert a new item at position n in a #PLIST_ARRAY node.\n\n @param node the node of type #PLIST_ARRAY\n @param item the new item to insert. The array is responsible for freeing item when it is no longer needed.\n @param n The position at which the node will be stored. Range is [0, array_size[. Assert if n is not in range."]
    pub fn plist_array_insert_item(node: plist_t, item: plist_t, n: u32);
}
extern "C" {
    #[doc = " Remove an existing position in a #PLIST_ARRAY node.\n Removed position will be freed using #plist_free.\n\n @param node the node of type #PLIST_ARRAY\n @param n The position to remove. Range is [0, array_size[. Assert if n is not in range."]
    pub fn plist_array_remove_item(node: plist_t, n: u32);
}
extern "C" {
    #[doc = " Remove a node that is a child node of a #PLIST_ARRAY node.\n node will be freed using #plist_free.\n\n @param node The node to be removed from its #PLIST_ARRAY parent."]
    pub fn plist_array_item_remove(node: plist_t);
}
extern "C" {
    #[doc = " Create an iterator of a #PLIST_ARRAY node.\n The allocated iterator should be freed with the standard free function.\n\n @param node The node of type #PLIST_ARRAY\n @param iter Location to store the iterator for the array."]
    pub fn plist_array_new_iter(node: plist_t, iter: *mut plist_array_iter);
}
extern "C" {
    #[doc = " Increment iterator of a #PLIST_ARRAY node.\n\n @param node The node of type #PLIST_ARRAY.\n @param iter Iterator of the array\n @param item Location to store the item. The caller must *not* free the\n          returned item. Will be set to NULL when no more items are left\n          to iterate."]
    pub fn plist_array_next_item(node: plist_t, iter: plist_array_iter, item: *mut plist_t);
}
extern "C" {
    #[doc = " Get size of a #PLIST_DICT node.\n\n @param node the node of type #PLIST_DICT\n @return size of the #PLIST_DICT node"]
    pub fn plist_dict_get_size(node: plist_t) -> u32;
}
extern "C" {
    #[doc = " Create an iterator of a #PLIST_DICT node.\n The allocated iterator should be freed with the standard free function.\n\n @param node The node of type #PLIST_DICT.\n @param iter Location to store the iterator for the dictionary."]
    pub fn plist_dict_new_iter(node: plist_t, iter: *mut plist_dict_iter);
}
extern "C" {
    #[doc = " Increment iterator of a #PLIST_DICT node.\n\n @param node The node of type #PLIST_DICT\n @param iter Iterator of the dictionary\n @param key Location to store the key, or NULL. The caller is responsible\n\t\tfor freeing the the returned string.\n @param val Location to store the value, or NULL. The caller must *not*\n\t\tfree the returned value. Will be set to NULL when no more\n\t\tkey/value pairs are left to iterate."]
    pub fn plist_dict_next_item(
        node: plist_t,
        iter: plist_dict_iter,
        key: *mut *mut ::std::os::raw::c_char,
        val: *mut plist_t,
    );
}
extern "C" {
    #[doc = " Get key associated key to an item. Item must be member of a dictionary.\n\n @param node the item\n @param key a location to store the key. The caller is responsible for freeing the returned string."]
    pub fn plist_dict_get_item_key(node: plist_t, key: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get the nth item in a #PLIST_DICT node.\n\n @param node the node of type #PLIST_DICT\n @param key the identifier of the item to get.\n @return the item or NULL if node is not of type #PLIST_DICT. The caller should not free\n\t\tthe returned node."]
    pub fn plist_dict_get_item(node: plist_t, key: *const ::std::os::raw::c_char) -> plist_t;
}
extern "C" {
    #[doc = " Get key node associated to an item. Item must be member of a dictionary.\n\n @param node the item\n @return the key node of the given item, or NULL."]
    pub fn plist_dict_item_get_key(node: plist_t) -> plist_t;
}
extern "C" {
    #[doc = " Set item identified by key in a #PLIST_DICT node.\n The previous item identified by key will be freed using #plist_free.\n If there is no item for the given key a new item will be inserted.\n\n @param node the node of type #PLIST_DICT\n @param item the new item associated to key\n @param key the identifier of the item to set."]
    pub fn plist_dict_set_item(node: plist_t, key: *const ::std::os::raw::c_char, item: plist_t);
}
extern "C" {
    #[doc = " Remove an existing position in a #PLIST_DICT node.\n Removed position will be freed using #plist_free\n\n @param node the node of type #PLIST_DICT\n @param key The identifier of the item to remove. Assert if identifier is not present."]
    pub fn plist_dict_remove_item(node: plist_t, key: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Merge a dictionary into another. This will add all key/value pairs\n from the source dictionary to the target dictionary, overwriting\n any existing key/value pairs that are already present in target.\n\n @param target pointer to an existing node of type #PLIST_DICT\n @param source node of type #PLIST_DICT that should be merged into target"]
    pub fn plist_dict_merge(target: *mut plist_t, source: plist_t);
}
extern "C" {
    #[doc = " Get a boolean value from a given #PLIST_DICT entry.\n\n The value node can be of type #PLIST_BOOLEAN, but also\n #PLIST_STRING (either 'true' or 'false'),\n #PLIST_INT with a numerical value of 0 or >= 1,\n or #PLIST_DATA with a single byte with a value of 0 or >= 1.\n\n @note This function returns 0 if the dictionary does not contain an\n entry for the given key, if the value node is of any other than\n the above mentioned type, or has any mismatching value.\n\n @param dict A node of type #PLIST_DICT\n @param key The key to look for in dict\n @return 0 or 1 depending on the value of the node."]
    pub fn plist_dict_get_bool(dict: plist_t, key: *const ::std::os::raw::c_char) -> u8;
}
extern "C" {
    #[doc = " Get a signed integer value from a given #PLIST_DICT entry.\n The value node can be of type #PLIST_INT, but also\n #PLIST_STRING with a numerical value as string (decimal or hexadecimal),\n or #PLIST_DATA with a size of 1, 2, 4, or 8 bytes in little endian byte order.\n\n @note This function returns 0 if the dictionary does not contain an\n entry for the given key, if the value node is of any other than\n the above mentioned type, or has any mismatching value.\n\n @param dict A node of type #PLIST_DICT\n @param key The key to look for in dict\n @return Signed integer value depending on the value of the node."]
    pub fn plist_dict_get_int(dict: plist_t, key: *const ::std::os::raw::c_char) -> i64;
}
extern "C" {
    #[doc = " Get an unsigned integer value from a given #PLIST_DICT entry.\n The value node can be of type #PLIST_INT, but also\n #PLIST_STRING with a numerical value as string (decimal or hexadecimal),\n or #PLIST_DATA with a size of 1, 2, 4, or 8 bytes in little endian byte order.\n\n @note This function returns 0 if the dictionary does not contain an\n entry for the given key, if the value node is of any other than\n the above mentioned type, or has any mismatching value.\n\n @param dict A node of type #PLIST_DICT\n @param key The key to look for in dict\n @return Signed integer value depending on the value of the node."]
    pub fn plist_dict_get_uint(dict: plist_t, key: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    #[doc = " Copy a node from *source_dict* to *target_dict*.\n The node is looked up in *source_dict* with given *key*, unless *alt_source_key*\n is non-NULL, in which case it is looked up with *alt_source_key*.\n The entry in *target_dict* is **always** created with *key*.\n\n @param target_dict The target dictionary to copy to.\n @param source_dict The source dictionary to copy from.\n @param key The key for the node to copy.\n @param alt_source_key The alternative source key for lookup in *source_dict* or NULL.\n\n @result PLIST_ERR_SUCCESS on success or PLIST_ERR_INVALID_ARG if the source dictionary does not contain\n     any entry with given key or alt_source_key."]
    pub fn plist_dict_copy_item(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Copy a boolean value from *source_dict* to *target_dict*.\n The node is looked up in *source_dict* with given *key*, unless *alt_source_key*\n is non-NULL, in which case it is looked up with *alt_source_key*.\n The entry in *target_dict* is **always** created with *key*.\n\n @note The boolean value from *source_dict* is retrieved with #plist_dict_get_bool,\n     but is **always** created as #PLIST_BOOLEAN in *target_dict*.\n\n @param target_dict The target dictionary to copy to.\n @param source_dict The source dictionary to copy from.\n @param key The key for the node to copy.\n @param alt_source_key The alternative source key for lookup in *source_dict* or NULL.\n\n @result PLIST_ERR_SUCCESS on success or PLIST_ERR_INVALID_ARG if the source dictionary does not contain\n     any entry with given key or alt_source_key."]
    pub fn plist_dict_copy_bool(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Copy a signed integer value from *source_dict* to *target_dict*.\n The node is looked up in *source_dict* with given *key*, unless *alt_source_key*\n is non-NULL, in which case it is looked up with *alt_source_key*.\n The entry in *target_dict* is **always** created with *key*.\n\n @note The signed integer value from *source_dict* is retrieved with #plist_dict_get_int,\n     but is **always** created as #PLIST_INT.\n\n @param target_dict The target dictionary to copy to.\n @param source_dict The source dictionary to copy from.\n @param key The key for the node value to copy.\n @param alt_source_key The alternative source key for lookup in *source_dict* or NULL.\n\n @result PLIST_ERR_SUCCESS on success or PLIST_ERR_INVALID_ARG if the source dictionary does not contain\n     any entry with given key or alt_source_key."]
    pub fn plist_dict_copy_int(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Copy an unsigned integer value from *source_dict* to *target_dict*.\n The node is looked up in *source_dict* with given *key*, unless *alt_source_key*\n is non-NULL, in which case it is looked up with *alt_source_key*.\n The entry in *target_dict* is **always** created with *key*.\n\n @note The unsigned integer value from *source_dict* is retrieved with #plist_dict_get_uint,\n     but is **always** created as #PLIST_INT.\n\n @param target_dict The target dictionary to copy to.\n @param source_dict The source dictionary to copy from.\n @param key The key for the node value to copy.\n @param alt_source_key The alternative source key for lookup in *source_dict* or NULL.\n\n @result PLIST_ERR_SUCCESS on success or PLIST_ERR_INVALID_ARG if the source dictionary does not contain\n     any entry with given key or alt_source_key."]
    pub fn plist_dict_copy_uint(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Copy a #PLIST_DATA node from *source_dict* to *target_dict*.\n The node is looked up in *source_dict* with given *key*, unless *alt_source_key*\n is non-NULL, in which case it is looked up with *alt_source_key*.\n The entry in *target_dict* is **always** created with *key*.\n\n @note This function is like #plist_dict_copy_item, except that it fails\n     if the source node is not of type #PLIST_DATA.\n\n @param target_dict The target dictionary to copy to.\n @param source_dict The source dictionary to copy from.\n @param key The key for the node value to copy.\n @param alt_source_key The alternative source key for lookup in *source_dict* or NULL.\n\n @result PLIST_ERR_SUCCESS on success or PLIST_ERR_INVALID_ARG if the source dictionary does not contain\n     any entry with given key or alt_source_key, or if it is not of type #PLIST_DATA."]
    pub fn plist_dict_copy_data(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Copy a #PLIST_STRING node from *source_dict* to *target_dict*.\n The node is looked up in *source_dict* with given *key*, unless *alt_source_key*\n is non-NULL, in which case it is looked up with *alt_source_key*.\n The entry in *target_dict* is **always** created with *key*.\n\n @note This function is like #plist_dict_copy_item, except that it fails\n     if the source node is not of type #PLIST_STRING.\n\n @param target_dict The target dictionary to copy to.\n @param source_dict The source dictionary to copy from.\n @param key The key for the node value to copy.\n @param alt_source_key The alternative source key for lookup in *source_dict* or NULL.\n\n @result PLIST_ERR_SUCCESS on success or PLIST_ERR_INVALID_ARG if the source dictionary does not contain\n     any entry with given key or alt_source_key, or if it is not of type #PLIST_STRING."]
    pub fn plist_dict_copy_string(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Get the parent of a node\n\n @param node the parent (NULL if node is root)"]
    pub fn plist_get_parent(node: plist_t) -> plist_t;
}
extern "C" {
    #[doc = " Get the #plist_type of a node.\n\n @param node the node\n @return the type of the node"]
    pub fn plist_get_node_type(node: plist_t) -> plist_type;
}
extern "C" {
    #[doc = " Get the value of a #PLIST_KEY node.\n This function does nothing if node is not of type #PLIST_KEY\n\n @param node the node\n @param val a pointer to a C-string. This function allocates the memory,\n            caller is responsible for freeing it.\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_get_key_val(node: plist_t, val: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get the value of a #PLIST_STRING node.\n This function does nothing if node is not of type #PLIST_STRING\n\n @param node the node\n @param val a pointer to a C-string. This function allocates the memory,\n            caller is responsible for freeing it. Data is UTF-8 encoded.\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_get_string_val(node: plist_t, val: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get a pointer to the buffer of a #PLIST_STRING node.\n\n @note DO NOT MODIFY the buffer. Mind that the buffer is only available\n   until the plist node gets freed. Make a copy if needed.\n\n @param node The node\n @param length If non-NULL, will be set to the length of the string\n\n @return Pointer to the NULL-terminated buffer."]
    pub fn plist_get_string_ptr(node: plist_t, length: *mut u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the value of a #PLIST_BOOLEAN node.\n This function does nothing if node is not of type #PLIST_BOOLEAN\n\n @param node the node\n @param val a pointer to a uint8_t variable."]
    pub fn plist_get_bool_val(node: plist_t, val: *mut u8);
}
extern "C" {
    #[doc = " Get the unsigned integer value of a #PLIST_INT node.\n This function does nothing if node is not of type #PLIST_INT\n\n @param node the node\n @param val a pointer to a uint64_t variable."]
    pub fn plist_get_uint_val(node: plist_t, val: *mut u64);
}
extern "C" {
    #[doc = " Get the signed integer value of a #PLIST_INT node.\n This function does nothing if node is not of type #PLIST_INT\n\n @param node the node\n @param val a pointer to a int64_t variable."]
    pub fn plist_get_int_val(node: plist_t, val: *mut i64);
}
extern "C" {
    #[doc = " Get the value of a #PLIST_REAL node.\n This function does nothing if node is not of type #PLIST_REAL\n\n @param node the node\n @param val a pointer to a double variable."]
    pub fn plist_get_real_val(node: plist_t, val: *mut f64);
}
extern "C" {
    #[doc = " Get the value of a #PLIST_DATA node.\n This function does nothing if node is not of type #PLIST_DATA\n\n @param node the node\n @param val a pointer to an unallocated char buffer. This function allocates the memory,\n            caller is responsible for freeing it.\n @param length the length of the buffer\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_get_data_val(
        node: plist_t,
        val: *mut *mut ::std::os::raw::c_char,
        length: *mut u64,
    );
}
extern "C" {
    #[doc = " Get a pointer to the data buffer of a #PLIST_DATA node.\n\n @note DO NOT MODIFY the buffer. Mind that the buffer is only available\n   until the plist node gets freed. Make a copy if needed.\n\n @param node The node\n @param length Pointer to a uint64_t that will be set to the length of the buffer\n\n @return Pointer to the buffer"]
    pub fn plist_get_data_ptr(node: plist_t, length: *mut u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the value of a #PLIST_DATE node.\n This function does nothing if node is not of type #PLIST_DATE\n\n @param node the node\n @param sec a pointer to an int32_t variable. Represents the number of seconds since 01/01/2001.\n @param usec a pointer to an int32_t variable. Represents the number of microseconds"]
    pub fn plist_get_date_val(node: plist_t, sec: *mut i32, usec: *mut i32);
}
extern "C" {
    #[doc = " Get the value of a #PLIST_UID node.\n This function does nothing if node is not of type #PLIST_UID\n\n @param node the node\n @param val a pointer to a uint64_t variable."]
    pub fn plist_get_uid_val(node: plist_t, val: *mut u64);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_KEY\n\n @param node the node\n @param val the key value"]
    pub fn plist_set_key_val(node: plist_t, val: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_STRING\n\n @param node the node\n @param val the string value. The string is copied when set and will be\n\t\tfreed by the node."]
    pub fn plist_set_string_val(node: plist_t, val: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_BOOLEAN\n\n @param node the node\n @param val the boolean value"]
    pub fn plist_set_bool_val(node: plist_t, val: u8);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_INT\n\n @param node the node\n @param val the unsigned integer value"]
    pub fn plist_set_uint_val(node: plist_t, val: u64);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_INT\n\n @param node the node\n @param val the signed integer value"]
    pub fn plist_set_int_val(node: plist_t, val: i64);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_REAL\n\n @param node the node\n @param val the real value"]
    pub fn plist_set_real_val(node: plist_t, val: f64);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_DATA\n\n @param node the node\n @param val the binary buffer. The buffer is copied when set and will\n\t\tbe freed by the node.\n @param length the length of the buffer"]
    pub fn plist_set_data_val(node: plist_t, val: *const ::std::os::raw::c_char, length: u64);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_DATE\n\n @param node the node\n @param sec the number of seconds since 01/01/2001\n @param usec the number of microseconds"]
    pub fn plist_set_date_val(node: plist_t, sec: i32, usec: i32);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_UID\n\n @param node the node\n @param val the unsigned integer value"]
    pub fn plist_set_uid_val(node: plist_t, val: u64);
}
extern "C" {
    #[doc = " Export the #plist_t structure to XML format.\n\n @param plist the root node to export\n @param plist_xml a pointer to a C-string. This function allocates the memory,\n            caller is responsible for freeing it. Data is UTF-8 encoded.\n @param length a pointer to an uint32_t variable. Represents the length of the allocated buffer.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_to_xml(
        plist: plist_t,
        plist_xml: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Export the #plist_t structure to binary format.\n\n @param plist the root node to export\n @param plist_bin a pointer to a char* buffer. This function allocates the memory,\n            caller is responsible for freeing it.\n @param length a pointer to an uint32_t variable. Represents the length of the allocated buffer.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_to_bin(
        plist: plist_t,
        plist_bin: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Export the #plist_t structure to JSON format.\n\n @param plist the root node to export\n @param plist_json a pointer to a char* buffer. This function allocates the memory,\n     caller is responsible for freeing it.\n @param length a pointer to an uint32_t variable. Represents the length of the allocated buffer.\n @param prettify pretty print the output if != 0\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_to_json(
        plist: plist_t,
        plist_json: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
        prettify: ::std::os::raw::c_int,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Export the #plist_t structure to OpenStep format.\n\n @param plist the root node to export\n @param plist_openstep a pointer to a char* buffer. This function allocates the memory,\n     caller is responsible for freeing it.\n @param length a pointer to an uint32_t variable. Represents the length of the allocated buffer.\n @param prettify pretty print the output if != 0\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_to_openstep(
        plist: plist_t,
        plist_openstep: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
        prettify: ::std::os::raw::c_int,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Import the #plist_t structure from XML format.\n\n @param plist_xml a pointer to the xml buffer.\n @param length length of the buffer to read.\n @param plist a pointer to the imported plist.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure"]
    pub fn plist_from_xml(
        plist_xml: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Import the #plist_t structure from binary format.\n\n @param plist_bin a pointer to the xml buffer.\n @param length length of the buffer to read.\n @param plist a pointer to the imported plist.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure"]
    pub fn plist_from_bin(
        plist_bin: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Import the #plist_t structure from JSON format.\n\n @param json a pointer to the JSON buffer.\n @param length length of the buffer to read.\n @param plist a pointer to the imported plist.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure"]
    pub fn plist_from_json(
        json: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Import the #plist_t structure from OpenStep plist format.\n\n @param openstep a pointer to the OpenStep plist buffer.\n @param length length of the buffer to read.\n @param plist a pointer to the imported plist.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure"]
    pub fn plist_from_openstep(
        openstep: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Import the #plist_t structure from memory data.\n\n This function will look at the first bytes of plist_data\n to determine if plist_data contains a binary, JSON, OpenStep, or XML plist\n and tries to parse the data in the appropriate format.\n @note This is just a convenience function and the format detection is\n     very basic. It checks with plist_is_binary() if the data supposedly\n     contains binary plist data, if not it checks if the first bytes have\n     either '{' or '[' and assumes JSON format, and XML tags will result\n     in parsing as XML, otherwise it will try to parse as OpenStep.\n\n @param plist_data A pointer to the memory buffer containing plist data.\n @param length Length of the buffer to read.\n @param plist A pointer to the imported plist.\n @param format If non-NULL, the #plist_format_t value pointed to will be set to the parsed format.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure"]
    pub fn plist_from_memory(
        plist_data: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
        format: *mut plist_format_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Import the #plist_t structure directly from file.\n\n This function will look at the first bytes of the file data\n to determine if it contains a binary, JSON, OpenStep, or XML plist\n and tries to parse the data in the appropriate format.\n Uses plist_from_memory() internally.\n\n @param filename The name of the file to parse.\n @param plist A pointer to the imported plist.\n @param format If non-NULL, the #plist_format_t value pointed to will be set to the parsed format.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure"]
    pub fn plist_read_from_file(
        filename: *const ::std::os::raw::c_char,
        plist: *mut plist_t,
        format: *mut plist_format_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Write the #plist_t structure to a NULL-terminated string using the given format and options.\n\n @param plist The input plist structure\n @param output Pointer to a char* buffer. This function allocates the memory,\n     caller is responsible for freeing it.\n @param length A pointer to a uint32_t value that will receive the lenght of the allocated buffer.\n @param format A #plist_format_t value that specifies the output format to use.\n @param options One or more bitwise ORed values of #plist_write_options_t.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure.\n @note Use plist_mem_free() to free the allocated memory.\n @note #PLIST_FORMAT_BINARY is not supported by this function."]
    pub fn plist_write_to_string(
        plist: plist_t,
        output: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
        format: plist_format_t,
        options: plist_write_options_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Write the #plist_t structure to a FILE* stream using the given format and options.\n\n @param plist The input plist structure\n @param stream A writeable FILE* stream that the data will be written to.\n @param format A #plist_format_t value that specifies the output format to use.\n @param options One or more bitwise ORed values of #plist_write_options_t.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure.\n @note While this function allows all formats to be written to the given stream,\n     only the formats #PLIST_FORMAT_PRINT, #PLIST_FORMAT_LIMD, and #PLIST_FORMAT_PLUTIL\n     (basically all output-only formats) are directly and efficiently written to the stream;\n     the other formats are written to a memory buffer first."]
    pub fn plist_write_to_stream(
        plist: plist_t,
        stream: *mut FILE,
        format: plist_format_t,
        options: plist_write_options_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Write the #plist_t structure to a file at given path using the given format and options.\n\n @param plist The input plist structure\n @param filename The file name of the file to write to. Existing files will be overwritten.\n @param format A #plist_format_t value that specifies the output format to use.\n @param options One or more bitwise ORed values of #plist_write_options_t.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure.\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_write_to_file(
        plist: plist_t,
        filename: *const ::std::os::raw::c_char,
        format: plist_format_t,
        options: plist_write_options_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Print the given plist in human-readable format to standard output.\n This is equivalent to\n <code>plist_write_to_stream(plist, stdout, PLIST_FORMAT_PRINT, PLIST_OPT_PARTIAL_DATA);</code>\n @param plist The #plist_t structure to print\n @note For #PLIST_DATA nodes, only a maximum of 24 bytes (first 16 and last 8) are written."]
    pub fn plist_print(plist: plist_t);
}
extern "C" {
    #[doc = " Test if in-memory plist data is in binary format.\n This function will look at the first bytes of plist_data to determine\n if it supposedly contains a binary plist.\n @note The function is not validating the whole memory buffer to check\n if the content is truly a plist, it is only using some heuristic on\n the first few bytes of plist_data.\n\n @param plist_data a pointer to the memory buffer containing plist data.\n @param length length of the buffer to read.\n @return 1 if the buffer is a binary plist, 0 otherwise."]
    pub fn plist_is_binary(
        plist_data: *const ::std::os::raw::c_char,
        length: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a node from its path. Each path element depends on the associated father node type.\n For Dictionaries, var args are casted to const char*, for arrays, var args are caster to uint32_t\n Search is breath first order.\n\n @param plist the node to access result from.\n @param length length of the path to access\n @return the value to access."]
    pub fn plist_access_path(plist: plist_t, length: u32, ...) -> plist_t;
}
extern "C" {
    #[doc = " Variadic version of #plist_access_path.\n\n @param plist the node to access result from.\n @param length length of the path to access\n @param v list of array's index and dic'st key\n @return the value to access."]
    pub fn plist_access_pathv(plist: plist_t, length: u32, v: va_list) -> plist_t;
}
extern "C" {
    #[doc = " Compare two node values\n\n @param node_l left node to compare\n @param node_r rigth node to compare\n @return TRUE is type and value match, FALSE otherwise."]
    pub fn plist_compare_node_value(node_l: plist_t, node_r: plist_t) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Helper function to check the value of a PLIST_BOOL node.\n\n @param boolnode node of type PLIST_BOOL\n @return 1 if the boolean node has a value of TRUE or 0 if FALSE."]
    pub fn plist_bool_val_is_true(boolnode: plist_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to test if a given #PLIST_INT node's value is negative\n\n @param intnode node of type PLIST_INT\n @return 1 if the node's value is negative, or 0 if positive."]
    pub fn plist_int_val_is_negative(intnode: plist_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_INT node against\n a given signed integer value.\n\n @param uintnode node of type PLIST_INT\n @param cmpval value to compare against\n @return 0 if the node's value and cmpval are equal,\n         1 if the node's value is greater than cmpval,\n         or -1 if the node's value is less than cmpval."]
    pub fn plist_int_val_compare(uintnode: plist_t, cmpval: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_INT node against\n a given unsigned integer value.\n\n @param uintnode node of type PLIST_INT\n @param cmpval value to compare against\n @return 0 if the node's value and cmpval are equal,\n         1 if the node's value is greater than cmpval,\n         or -1 if the node's value is less than cmpval."]
    pub fn plist_uint_val_compare(uintnode: plist_t, cmpval: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_UID node against\n a given value.\n\n @param uidnode node of type PLIST_UID\n @param cmpval value to compare against\n @return 0 if the node's value and cmpval are equal,\n         1 if the node's value is greater than cmpval,\n         or -1 if the node's value is less than cmpval."]
    pub fn plist_uid_val_compare(uidnode: plist_t, cmpval: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_REAL node against\n a given value.\n\n @note WARNING: Comparing floating point values can give inaccurate\n     results because of the nature of floating point values on computer\n     systems. While this function is designed to be as accurate as\n     possible, please don't rely on it too much.\n\n @param realnode node of type PLIST_REAL\n @param cmpval value to compare against\n @return 0 if the node's value and cmpval are (almost) equal,\n         1 if the node's value is greater than cmpval,\n         or -1 if the node's value is less than cmpval."]
    pub fn plist_real_val_compare(realnode: plist_t, cmpval: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_DATE node against\n a given set of seconds and fraction of a second since epoch.\n\n @param datenode node of type PLIST_DATE\n @param cmpsec number of seconds since epoch to compare against\n @param cmpusec fraction of a second in microseconds to compare against\n @return 0 if the node's date is equal to the supplied values,\n         1 if the node's date is greater than the supplied values,\n         or -1 if the node's date is less than the supplied values."]
    pub fn plist_date_val_compare(
        datenode: plist_t,
        cmpsec: i32,
        cmpusec: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_STRING node against\n a given value.\n This function basically behaves like strcmp.\n\n @param strnode node of type PLIST_STRING\n @param cmpval value to compare against\n @return 0 if the node's value and cmpval are equal,\n     > 0 if the node's value is lexicographically greater than cmpval,\n     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_string_val_compare(
        strnode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_STRING node against\n a given value, while not comparing more than n characters.\n This function basically behaves like strncmp.\n\n @param strnode node of type PLIST_STRING\n @param cmpval value to compare against\n @param n maximum number of characters to compare\n @return 0 if the node's value and cmpval are equal,\n     > 0 if the node's value is lexicographically greater than cmpval,\n     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_string_val_compare_with_size(
        strnode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to match a given substring in the value of a\n PLIST_STRING node.\n\n @param strnode node of type PLIST_STRING\n @param substr value to match\n @return 1 if the node's value contains the given substring,\n     or 0 if not."]
    pub fn plist_string_val_contains(
        strnode: plist_t,
        substr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_KEY node against\n a given value.\n This function basically behaves like strcmp.\n\n @param keynode node of type PLIST_KEY\n @param cmpval value to compare against\n @return 0 if the node's value and cmpval are equal,\n     > 0 if the node's value is lexicographically greater than cmpval,\n     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_key_val_compare(
        keynode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_KEY node against\n a given value, while not comparing more than n characters.\n This function basically behaves like strncmp.\n\n @param keynode node of type PLIST_KEY\n @param cmpval value to compare against\n @param n maximum number of characters to compare\n @return 0 if the node's value and cmpval are equal,\n     > 0 if the node's value is lexicographically greater than cmpval,\n     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_key_val_compare_with_size(
        keynode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to match a given substring in the value of a\n PLIST_KEY node.\n\n @param keynode node of type PLIST_KEY\n @param substr value to match\n @return 1 if the node's value contains the given substring,\n     or 0 if not."]
    pub fn plist_key_val_contains(
        keynode: plist_t,
        substr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the data of a PLIST_DATA node against\n a given blob and size.\n This function basically behaves like memcmp after making sure the\n size of the node's data value is equal to the size of cmpval (n),\n making this a \"full match\" comparison.\n\n @param datanode node of type PLIST_DATA\n @param cmpval data blob to compare against\n @param n size of data blob passed in cmpval\n @return 0 if the node's data blob and cmpval are equal,\n     > 0 if the node's value is lexicographically greater than cmpval,\n     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_data_val_compare(
        datanode: plist_t,
        cmpval: *const u8,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the data of a PLIST_DATA node against\n a given blob and size, while no more than n bytes are compared.\n This function basically behaves like memcmp after making sure the\n size of the node's data value is at least n, making this a\n \"starts with\" comparison.\n\n @param datanode node of type PLIST_DATA\n @param cmpval data blob to compare against\n @param n size of data blob passed in cmpval\n @return 0 if the node's value and cmpval are equal,\n     > 0 if the node's value is lexicographically greater than cmpval,\n     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_data_val_compare_with_size(
        datanode: plist_t,
        cmpval: *const u8,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to match a given data blob within the value of a\n PLIST_DATA node.\n\n @param datanode node of type PLIST_KEY\n @param cmpval data blob to match\n @param n size of data blob passed in cmpval\n @return 1 if the node's value contains the given data blob\n     or 0 if not."]
    pub fn plist_data_val_contains(
        datanode: plist_t,
        cmpval: *const u8,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sort all PLIST_DICT key/value pairs in a property list lexicographically\n by key. Recurses into the child nodes if necessary.\n\n @param plist The property list to perform the sorting operation on."]
    pub fn plist_sort(plist: plist_t);
}
extern "C" {
    #[doc = " Free memory allocated by relevant libplist API calls:\n - plist_to_xml()\n - plist_to_bin()\n - plist_get_key_val()\n - plist_get_string_val()\n - plist_get_data_val()\n\n @param ptr pointer to the memory to free\n\n @note Do not use this function to free plist_t nodes, use plist_free()\n     instead."]
    pub fn plist_mem_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Set debug level for the format parsers.\n @note This function does nothing if libplist was not configured with --enable-debug .\n\n @param debug Debug level. Currently, only 0 (off) and 1 (enabled) are supported."]
    pub fn plist_set_debug(debug: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Returns a static string of the libplist version.\n\n @return The libplist version as static ascii string"]
    pub fn libplist_version() -> *const ::std::os::raw::c_char;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
